{"version":3,"file":"static/js/659.ac7bfb1e.chunk.js","mappings":"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","sources":["components/charPage/CharPage.js","components/errorMessage/ErrorMessage.js","components/randomChar/RandomChar.js","components/charList/CharList.js","components/charInfo/CharInfo.js","components/charForm/CharForm.js","components/errorBoundary/ErrorBoundary.js","components/pages/MainPage.js","hooks/http.hook.js","services/MarvelService.js","components/skeleton/Skeleton.js","utils/setContent.js"],"sourcesContent":["import { Helmet } from 'react-helmet';\r\n\r\nimport { useParams } from 'react-router-dom';\r\nimport { useState, useEffect } from \"react\";\r\n\r\n// эти два импорта больше не нужны, т.к. они вшиты в setContent\r\n// import Spinner from '../spinner/Spinners';\r\n// import ErrorMessage from '../errorMessage/ErrorMessage';\r\nimport useMarvelService from \"../../services/MarvelService\";\r\nimport setContent from '../../utils/setContent';\r\n\r\nimport './charPage.scss'\r\n\r\nconst CharPage = () => {\r\n\r\n    const {id} = useParams();\r\n    const [char, setChar] = useState([]);\r\n    const {loading, error, clearError, getCharacter, process, setProcess} = useMarvelService();\r\n\r\n    useEffect(() => {\r\n        updateChar();\r\n    }, [id])\r\n\r\n    const updateChar = () => {\r\n        clearError();\r\n        getCharacter(id)\r\n            .then(data => setChar(data))\r\n            .then(() => setProcess('confirmed'))\r\n    }\r\n\r\n    // const errorMessage = error ? <ErrorMessage/> : null; \r\n    // const spinner = loading ? <Spinner/> : null; \r\n    // const content = (!error && !loading && char) ? <View char={char}></View> : null;\r\n\r\n    return (\r\n        <>\r\n            {setContent(process, View, char)}\r\n        </>\r\n    )\r\n}\r\n\r\nexport default CharPage;\r\n\r\nconst View = ({data}) => {\r\n    const {thumbnail, description, name} = data;\r\n    return (\r\n        <div className=\"char-page\">\r\n            <Helmet>\r\n                <meta\r\n                    name=\"description\"\r\n                    content={`Page about ${name}`}\r\n                />\r\n                <title>{`${name} page`}</title>\r\n            </Helmet>\r\n            <img src={thumbnail} alt={name} className=\"char-page__img\"/>\r\n            <div className=\"char-page__info\">\r\n                <h2 className=\"char-page__name\">{name}</h2>\r\n                <p className=\"char-page__descr\">{description}</p>\r\n            </div>\r\n        </div>\r\n    )\r\n}","import imgError from './error.gif'\r\n\r\nconst ErrorMessage = () => {\r\n    return (\r\n        <img style={{ display: 'block', width: \"250px\", height: \"250px\",objectFit: 'contain', margin: \"0 auto\"}} src={imgError} alt={'Ошибка загрузки'}></img>\r\n    )\r\n}\r\n\r\nexport default ErrorMessage;","import { useState, useEffect } from 'react';\n\n// эти два импорта больше не нужны, т.к. они вшиты в setContent\n// import Spinner from '../spinner/Spinners';\n// import ErrorMessage from '../errorMessage/ErrorMessage';\nimport useMarvelService from '../../services/MarvelService';\nimport setContent from '../../utils/setContent';\n\nimport './randomChar.scss';\nimport mjolnir from '../../resources/img/mjolnir.png';\n\n// функциональный подход\nconst RandomChar = () => {\n    // поля классов позволяют прописывать такой лаконичный код для стэйтов\n    const [char, setChar] = useState({});\n    // эти два состояния теперь будут приходить из useMarvelService, так что их можно не прописывать\n    // const [loading, setLoading] = useState(true);\n    // const [error, setError] = useState(false);\n    // выше мы импортировали наш хук с запросом на сервер, здесь его будем использовать\n    const {loading, error, getCharacter, clearError, process, setProcess} = useMarvelService(); // вытаскиваем из вызова хука два состояния и метод, кт будет использоваться в этом компоненте\n\n    // пропишем метод, который правильным образом при первой загрузке страницы будет запускать наш компонент, не выдавая багов, как это было при запуске метода через Constructor\n    useEffect(() => {\n        updateChar();\n        // timerId = setInterval(this.updateChar, 300000); // сделаем, чтобы обновление компонента шло через интервалы времени\n        // return () => {\n        //     clearInterval(timerId);\n        // }\n    }, [])\n\n\n    // пропишем метод, который будет обновлять стэйт char\n    const onCharLoaded = (char) => {\n        setChar(char);\n        // код ниже убираем, потому что его работу будет выполнять useHttp - хук, который, по сути, придёт и сработает от useMarvelService\n        // setLoading(false); // если данные от сервера вернулись (стэйту char присвоилось какое-то значение), то loading переходит в состояние false, чтобы в вёрстке отобразились загруженные данные, а не спиннер загрузки\n    }\n    \n    // методы onCharLoading и onError мы убираем, потому что их функционал прописан в useHttp - хуке, который, по сути, придёт и сработает из useMarvelService\n    // пропишем метод, который будет запускать спиннер загрузки\n    // const onCharLoading = () => {\n    //     setLoading(true);\n    // }\n    \n    // пропишем метод, который будет отображать ошибку, если от сервера не пришёл ответ\n    // const onError = () => {\n    //     setLoading(false); // статус загрузки меняется на false, потому что она завершилась неудачно\n    //     setError(true);\n    // }\n\n    // пропишем метод, который будет обращаться к серверу, получать от него данные и их использовать для обновления state\n    const updateChar = () => {\n        clearError(); // после каждого обновления персонажа предусмотрим эту функцию, кт очищает ошибку. В противном случае, если вылезет ошибка, то кнопка с вызовом случайного персонажа перестанет работать\n        const id = Math.floor(Math.random() * (1011400 - 1011000) + 1011000); // получаем id рандомного персонажа\n        // onCharLoading(); // убираем, потому что это сработает из метода getCharacter, который мы получили из useMarvelService\n        // useMarvelService // делаем запрос на сервер\n        getCharacter(id) // получаем только нужные и уже преобразованные данные о персонаже\n            .then(onCharLoaded) // обновляем стэйт char данными о персонаже\n            .then(() => setProcess('confirmed'));\n            // код ниже можно убрать, потому что обработка ошибок предусмотрена ещё в useHttp, кт является основой для useMarvelService и его методов\n            // .catch(onError) // если будет ошибка, высветится соответствующее сообщение\n    }\n\n    // это больше не нужно благодаря setContent\n    // чтобы не расписывать сложные выражения в вёрстке ниже, пропишем их тут, это хорошая практика\n    // const errorMessage = error ? <ErrorMessage></ErrorMessage> : null; // если получена ошибка, этой переменной будет присвоен в качестве значения компонент с ошибкой, иначе null\n    // const spinner = loading ? <Spinner></Spinner> : null; // если идёт загрузка, этой переменной будет присвоен в качестве значения компонент со спинером загрузки, иначе null\n    // const content = (!error && !loading) ? <View char={char}></View> : null; // если нет загрузки и нет ошибки, будет показан контент с данными о персонаже, иначе null\n\n    return (\n        // если идёт загрузка, то в левой части будет крутиться спиннер, если закрузка завершена, то будут показываться данные о персонаже\n        <div className=\"randomchar\">\n            {setContent(process, View, char)}\n            <div className=\"randomchar__static\">\n                <p className=\"randomchar__title\">\n                    Random character for today!<br/>\n                    Do you want to get to know him better?\n                </p>\n                <p className=\"randomchar__title\">\n                    Or choose another one\n                </p>\n                <button className=\"button button__main\" onClick={updateChar}>\n                    <div className=\"inner\">try it</div>\n                </button>\n                <img src={mjolnir} alt=\"mjolnir\" className=\"randomchar__decoration\"/>\n            </div>\n        </div>\n    )\n}\n\n// классовый подход\n// class RandomChar extends Component{\n//     // чтобы при загрузке страницы в этом компоненте отобразились данные, то через конструктор мы вызываем метод, который получает данные от сервера\n//     // это работает, но может вызвать баги, т.к. метод срабатывает раньше, чем отрисовалась страница\n//     // позже этот приём будет заменён на корректный код\n//     // constructor(props) {\n//     //     super(props);\n//     //     this.updateChar();\n//     // }\n//     // поля классов позволяют прописывать такой лаконичный код для стэйтов\n//     state = { // стэйтов может быть много, не только с данными о персонаже, поэтому данные о персонаже вынесем в отдельный стэйт с объектом, внутри которого и будут эти данные о персонаже\n//         char: {},\n//         loading: true,\n//         error: false\n//     }\n    \n//     // пропишем метод, который правильным образом при первой загрузке страницы будет запускать наш компонент, не выдавая багов, как это было при запуске метода через Constructor\n//     componentDidMount() {\n//         this.updateChar();\n//         // this.timerId = setInterval(this.updateChar, 300000); // сделаем, чтобы обновление компонента шло через интервалы времени\n//     }\n\n//     componentWillUnmount() {\n//         clearInterval(this.timerId); // чтобы запросы бесконечно не направлялись на сервер, нужно предусматривать при удалении компонента ещё и удаление интервального срабатывания обновления\n//     }\n\n//     marvelService = new MarvelService(); // выше мы импортировали наш метод с запросом на сервер, здесь его будем использовать\n\n//     // пропишем метод, который будет обновлять стэйт char\n//     onCharLoaded = (char) => {\n//         this.setState({\n//             char, \n//             loading: false}) // если данные от сервера вернулись (стэйту char присвоилось какое-то значение), то loading переходит в состояние false, чтобы в вёрстке отобразились загруженные данные, а не спиннер загрузки\n//     }\n    \n//     // пропишем метод, который будет запускать спиннер загрузки\n//     onCharLoading = () => {\n//         this.setState({\n//             loading: true\n//         })\n//     }\n    \n//     // создаём метод, который будет отображать ошибку, если от сервера не пришёл ответ\n//     onError = () => {\n//         this.setState({\n//             loading: false, // статус загрузки меняется на false, потому что она завершилась неудачно\n//             error: true})\n//     }\n\n//     // пропишем метод, который будет обращаться к серверу, получать от него данные и их использовать для обновления state\n//     updateChar = () => {\n//         const id = Math.floor(Math.random() * (1011400 - 1011000) + 1011000); // получаем id рандомного персонажа\n//         this.onCharLoading();\n//         this.marvelService // делаем запрос на сервер\n//             .getCharacter(id) // получаем только нужные и уже преобразованные данные о персонаже\n//             .then(this.onCharLoaded) // обновляем стэйт char данными о персонаже\n//             .catch(this.onError) // если будет ошибка, высветится соответствующее сообщение\n//     }\n\n//     render() {\n//         const {char, loading, error} = this.state; // тут двойная деструктуризация, потому что данные лежат не просто в стэйте, а в объекте, кт внутри стэйта\n//         // чтобы не расписывать сложные выражения в вёрстке ниже, пропишем их тут, это хорошая практика\n//         const errorMessage = error ? <ErrorMessage></ErrorMessage> : null; // если получена ошибка, этой переменной будет присвоен в качестве значения компонент с ошибкой, иначе null\n//         const spinner = loading ? <Spinner></Spinner> : null; // если идёт загрузка, этой переменной будет присвоен в качестве значения компонент со спинером загрузки, иначе null\n//         const content = (!error && !loading) ? <View char={char}></View> : null; // если нет загрузки и нет ошибки, будет показан контент с данными о персонаже, иначе null\n\n//         return (\n//             // если идёт загрузка, то в левой части будет крутиться спиннер, если закрузка завершена, то будут показываться данные о персонаже\n//             <div className=\"randomchar\">\n//                 {errorMessage}\n//                 {spinner}\n//                 {content}\n//                 <div className=\"randomchar__static\">\n//                     <p className=\"randomchar__title\">\n//                         Random character for today!<br/>\n//                         Do you want to get to know him better?\n//                     </p>\n//                     <p className=\"randomchar__title\">\n//                         Or choose another one\n//                     </p>\n//                     <button className=\"button button__main\" onClick={this.updateChar}>\n//                         <div className=\"inner\">try it</div>\n//                     </button>\n//                     <img src={mjolnir} alt=\"mjolnir\" className=\"randomchar__decoration\"/>\n//                 </div>\n//             </div>\n//         )\n//     }\n// }\n\n// создадим отдельный компонент, который будет просто создавать вёрстку\nconst View = ({data}) => {\n    const {name, description, thumbnail, homepage, wiki} = data;\n    let thumnailUrl = thumbnail === `http://i.annihil.us/u/prod/marvel/i/mg/b/40/image_not_available.jpg`;\n    let thumbnailStyle = thumnailUrl ? {objectFit: 'contain'} : null;\n\n    return (\n        <div className=\"randomchar__block\">\n            <img src={thumbnail} alt=\"Random character\" className=\"randomchar__img\" style={thumbnailStyle}/>\n            <div className=\"randomchar__info\">\n                <p className=\"randomchar__name\">{name}</p>\n                <p className=\"randomchar__descr\">\n                    {description}\n                </p>\n                <div className=\"randomchar__btns\">\n                    <a href={homepage} className=\"button button__main\">\n                        <div className=\"inner\">homepage</div>\n                    </a>\n                    <a href={wiki} className=\"button button__secondary\">\n                        <div className=\"inner\">Wiki</div>\n                    </a>\n                </div>\n            </div>\n        </div>\n    )\n}\n\nexport default RandomChar;","import { useState, useEffect, useRef, useMemo } from 'react';\nimport { CSSTransition, TransitionGroup } from \"react-transition-group\";\n\nimport PropTypes from 'prop-types';\n\nimport useMarvelService from '../../services/MarvelService';\nimport ErrorMessage from '../errorMessage/ErrorMessage';\nimport Spinner from '../spinner/Spinners';\n\nimport './charList.scss';\n\n// вместо импорта setContent мы сами создаём такую же функцию, потому что у неё надо прописать немного другую логику\nconst setContent = (process, Component, newItemLoading) => {\n    switch(process) {\n        case 'waiting':\n            return <Spinner/>; // если у состояния процесса значение ожидания, значит, ещё не был отправлен запрос на сервер и пока на сайте у компонента стоит спиннер загрузки\n            break;\n        case 'loading':\n            return newItemLoading ? <Component/> : <Spinner/>; // если у состояния процесса значение загрузки и при этом идёт первая загрузка персонажей, значит, запрос пока впервые отправлен на сервер, поэтому будет показываться компонент загрузки, \n            // если будет не первая загрузка, а дозагрузка, показываться будет не спиннер загрузки, а ранее загруженные персонажи\n            break;\n        case 'confirmed':\n            return <Component/>; // если у состояния процесса значение подтверждено, значит, от сервера пришли данные, а не ошибка, тогда загружается полученный контент\n            break;\n        case 'error':\n            return <ErrorMessage/>; // если у состония процесса значение ошибки, значит, от сервера не пришли данные, а возникла ошибка, тогда показывается компонент с ошибкой\n            break;\n        default:\n            throw new Error('Unexpected process state');\n    }\n}\n\n// это функциональный подход\nconst CharList = (props) => {\n\n    const [charList, setCharList] = useState([]);\n    // эти два состояния убираем, они будут приходить из useMarvelService (подробные описания - почему - в компоненте RandomChar)\n    // const [loading, setLoading] = useState(true);\n    // const [error, setError] = useState(false);\n    const [newItemLoading, setNewItemLoading] = useState(false);\n    const [offset, setOffset] = useState(210);\n    const [charEnded, setCharEnded] = useState(false);\n    const {loading, error, process, setProcess, getAllCharacters} = useMarvelService();\n\n    useEffect(() => { // мы можем написать useEffect здесь, до объявления стрелочной функции, потому что useEffect запускается после рендеринга, а к этому времени функция уже будет объявлена\n        onRequest(offset, true);\n    }, []) // поставили пустой массив, чтобы сработало один раз при первом рендеринге\n\n    // метод по запросу на сервер\n    const onRequest = (offset, initial) => {\n        // если initial стоит в true, т.е. идёт первая загрузка, то спиннер загрузки дополнительных персонажей не появляется, в ином случае будет появляться\n        initial ? setNewItemLoading(false) : setNewItemLoading(true);\n        // onCharListLoading(); // вместо него будет сразу установка нового значения этого состояния:\n        getAllCharacters(offset) // получаем только нужные и уже преобразованные данные о персонажах\n            .then(onCharListLoaded) // обновляем стэйт char данными о персонажах\n            .then(() => setProcess('confirmed'))\n            // .catch(onError) // это уже не надо благодаря useMarvelService\n    }\n\n    // этот метод, в целом, отвечает за процесс загрузки списка персонажей\n    const onCharListLoaded = (newCharList) => { // как параметр получает новый массив (это массив, кт будет приходить от сервера, состоящий всегда из 9 персонажей)\n        let ended = false; // эта переменная будет использоваться как значение для стэйта charEnded\n        if (newCharList.length < 9) { // если от сервера пришло меньше 9 персонажей, значит, мы дошли до конца списка персонажей\n            ended = true;\n        }\n        // там, где важно предыдущее значение состояния, используем коллбэк-фукнции, в остальных местах можно просто присваивать новые значения\n        setCharList(charList => [...charList, ...newCharList]); // обновляем стэйт charList, перезаписывая в качестве его значения прежнее значение плюс новый массив, пришедший от сервера\n        // убираем строку ниже благодаря useMarvelService\n        // setLoading(false); // если данные от сервера вернулись (стэйту char присвоилось какое-то значение), то loading переходит в состояние false, чтобы в вёрстке отобразились загруженные данные, а не спиннер загрузки\n        setNewItemLoading(newItemLoading => false); \n        setOffset(offset => offset + 9); // при каждом срабатывании метода будет меняться значение этого стэйта\n        setCharEnded(charEnded => ended); // если сюда попадёт true, значит, мы дошли до конца списка персонажей, это будет ниже вызывать код, убирающий кнопку дозагрузки со страницы\n    }\n\n    // убираем благодаря useMarvelService\n    // const onError = () => {\n    //     setLoading(false); // статус загрузки меняется на false, потому что она завершилась неудачно\n    //     setError(true);\n    // }\n\n    const itemRefs = useRef([]); // пока что это пустой массив, в будущем в него будут помещаться карточки персонажей\n\n    const focusOnItem = (id) => {\n        itemRefs.current.forEach(item => item.classList.remove('char__item_selected'));\n        itemRefs.current[id].classList.add('char__item_selected');\n        itemRefs.current[id].focus();\n    }\n    const duration = 300;\n    // Этот метод создан для оптимизации, чтобы не помещать такую конструкцию в метод render\n    function renderItems(arr) {\n        const items =  arr.map((item, i) => {\n            let imgStyle = {'objectFit' : 'cover'};\n            if (item.thumbnail === 'http://i.annihil.us/u/prod/marvel/i/mg/b/40/image_not_available.jpg') {\n                imgStyle = {'objectFit' : 'unset'};\n            }\n            let classStyle = \"char__item\";\n\n            const duration = 300;\n            // А эта конструкция вынесена для центровки спиннера/ошибки\n            return (\n                <CSSTransition \n                    in={!newItemLoading} \n                    timeout={duration}\n                    classNames='charListItem'\n                    >\n                    <li \n                        className={classStyle}\n                        tabIndex={0}\n                        key={item.id}\n                        ref={el => itemRefs.current[i] = el}\n                        onClick={() => {\n                            props.onCharSelected(item.id)\n                            focusOnItem(i)\n                            }}\n                        onKeyPress={(e) => {\n                            if (e.key === ' ' || e.key === \"Enter\") {\n                                props.onCharSelected(item.id);\n                                focusOnItem(i);\n                            }\n                        }}> \n                        {/* хоть в компоненте и не выделен пропс, React знает, что он тут есть и сам подтягивает из App переданный как свойство метод onCharSelected */}\n                            <img src={item.thumbnail} alt={item.name} style={imgStyle}/>\n                            <div className=\"char__name\">{item.name}</div>\n                    </li>\n                </CSSTransition>\n                // при переборе каждый элемент будет заполнять массив itemRefs с карточками персонажей\n                // <li \n                //     className={classStyle}\n                //     tabIndex={0}\n                //     key={item.id}\n                //     ref={el => itemRefs.current[i] = el}\n                //     onClick={() => {\n                //         props.onCharSelected(item.id)\n                //         focusOnItem(i)\n                //         }}\n                //     onKeyPress={(e) => {\n                //         if (e.key === ' ' || e.key === \"Enter\") {\n                //             props.onCharSelected(item.id);\n                //             focusOnItem(i);\n                //         }\n                //     }}> \n                //     {/* хоть в компоненте и не выделен пропс, React знает, что он тут есть и сам подтягивает из App переданный как свойство метод onCharSelected */}\n                //         <img src={item.thumbnail} alt={item.name} style={imgStyle}/>\n                //         <div className=\"char__name\">{item.name}</div>\n                // </li>\n            )\n        });\n\n        return (\n            <TransitionGroup component={null}>\n                <ul className=\"char__grid\">\n                    {items}\n                </ul>\n            </TransitionGroup>\n        )\n    }\n\n    // после манипуляций с конечным автоматом появилась проблема, что не навешивается класс активности на выбранного персонажа, \n    // это происходит из-за того, что при клике на персонажа меняется пропс у родительского компонента и происходит повторный рендеринг компонента при том, что класс активности навесился на элемент из первого рендера\n    // для решения этой проблемы используем useMemo, чтобы он запомнил рендер и не вызывал новые рендеры списка персонажей даже в случае перерендеринга родительского компонента\n    const elements = useMemo(() => {\n        return setContent(process, () => renderItems(charList), newItemLoading);\n    }, [process]) // указываем состояние процесс, чтобы useMemo менялся только в случаях изменения состояния процесса\n    // const items = renderItems(charList); // он больше не нужен, потому что мы эту функцию передадим как аргумент в setContent в качестве аргумента Component\n\n    // const errorMessage = error ? <ErrorMessage></ErrorMessage> : null; \n    // const spinner = loading && !newItemLoading ? <Spinner></Spinner> : null; \n    // убираем строку ниже, потому что она теперь при дозагрузке персонажей сперва удаляет всех персонажей со странице, а потом показывает полный новый список, такое поведение нам не нужно, пусть просто показывает что-то\n    // такое поведение получилось из-за того, что мы внедрили useMarvelService\n    // const content = (!error && !loading) ? items : null; // если нет загрузки и нет ошибки, будет показан контент с данными о персонаже, иначе null\n\n    return (\n        <div className=\"char__list\">\n            {/* т.к. в аргументы setContent надо передавать компонент, а компонент это функция (сейчас всё на функциональных компонентах), возвращающая вёрстку, \n            то вторым аргументом передадим коллбэк-функцию, которая по итогу будет вызывать вёрстку, таким образом мы заменяем items*/}\n            {elements} \n            <button \n                className=\"button button__main button__long\"\n                disabled={newItemLoading}\n                style={{'display': charEnded ? 'none' : 'block'}}\n                onClick={() => onRequest(offset)}>\n                <div className=\"inner\">load more</div>\n            </button>\n        </div>\n    )\n}\n\n// это классовый подход\n// class CharList extends Component{\n//     state = {\n//         charList: [],\n//         loading: true, // это статус любого процесса загрузки списка персонажей\n//         newItemLoading: false, // это статус процесса дозагрузки списка персонажей\n//         error: false,\n//         offset: 210, // это размер отступа, кт будет передаваться в метод по работе с сервером, чтобы каждый раз мы получали новые 9 персонажей\n//         charEnded: false // это состояние показывает, закончился ли список персонажей у сервера\n//     }\n\n//     marvelService = new MarvelService();\n\n//     componentDidMount() {\n//         this.onRequest();\n//     }\n//     // метод по запросу на сервер\n//     onRequest = (offset) => {\n//         this.onCharListLoading();\n//         this.marvelService // делаем запрос на сервер\n//             .getAllCharacters(offset) // получаем только нужные и уже преобразованные данные о персонажах\n//             .then(this.onCharListLoaded) // обновляем стэйт char данными о персонажах\n//             .catch(this.onError)\n//     }\n\n//     // этот метод отвечает за состояние дозагрузки списка персонажей: идёт она или нет, чтобы пользователю показать\n//     onCharListLoading = () => {\n//         this.setState({\n//             newItemLoading: true\n//         })\n//     }\n\n//     // этот метод, в целом, отвечает за процесс загрузки списка персонажей\n//     onCharListLoaded = (newCharList) => { // как параметр получает новый массив (это массив, кт будет приходить от сервера, состоящий всегда из 9 персонажей)\n//         let ended = false; // эта переменная будет использоваться как значение для стэйта charEnded\n//         if (newCharList.length < 9) { // если от сервера пришло меньше 9 персонажей, значит, мы дошли до конца списка персонажей\n//             ended = true;\n//         }\n//         this.setState(({offset, charList}) => ({ // тут как параметр состояние стэйта charList и offset\n//             charList: [...charList, ...newCharList], // обновляем стэйт charList, перезаписывая в качестве его значения прежнее значение плюс новый массив, пришедший от сервера\n//             loading: false, // если данные от сервера вернулись (стэйту char присвоилось какое-то значение), то loading переходит в состояние false, чтобы в вёрстке отобразились загруженные данные, а не спиннер загрузки\n//             newItemLoading: false,\n//             offset: offset + 9, // при каждом срабатывании метода будет меняться значение этого стэйта\n//             charEnded: ended // если сюда попадёт true, значит, мы дошли до конца списка персонажей, это будет ниже вызывать код, убирающий кнопку дозагрузки со страницы\n//         }))\n//     }\n\n//     onError = () => {\n//         this.setState({\n//             loading: false, // статус загрузки меняется на false, потому что она завершилась неудачно\n//             error: true})\n//     }\n\n//     itemRefs = [];\n\n//     setRef = (ref) => {\n//         this.itemRefs.push(ref);\n//     }\n\n//     focusOnItem = (id) => {\n//         this.itemRefs.forEach(item => item.classList.remove('char__item_selected'));\n//         this.itemRefs[id].classList.add('char__item_selected');\n//         this.itemRefs[id].focus();\n//     }\n\n//     // Этот метод создан для оптимизации, чтобы не помещать такую конструкцию в метод render\n//     renderItems(arr) {\n//         const items =  arr.map((item, i) => {\n//             let imgStyle = {'objectFit' : 'cover'};\n//             if (item.thumbnail === 'http://i.annihil.us/u/prod/marvel/i/mg/b/40/image_not_available.jpg') {\n//                 imgStyle = {'objectFit' : 'unset'};\n//             }\n//             let classStyle = \"char__item\";\n//             // А эта конструкция вынесена для центровки спиннера/ошибки\n//             return (\n//                 <li \n//                     className={classStyle}\n//                     key={item.id}\n//                     ref={this.setRef}\n//                     onClick={() => {\n//                         this.props.onCharSelected(item.id)\n//                         this.focusOnItem(i)\n//                         }}\n//                     onKeyPress={(e) => {\n//                         if (e.key === ' ' || e.key === \"Enter\") {\n//                             this.props.onCharSelected(item.id);\n//                             this.focusOnItem(i);\n//                         }\n//                     }}> \n//                     {/* хоть в компоненте и не выделен пропс, React знает, что он тут есть и сам подтягивает из App переданный как свойство метод onCharSelected */}\n//                         <img src={item.thumbnail} alt={item.name} style={imgStyle}/>\n//                         <div className=\"char__name\">{item.name}</div>\n//                 </li>\n//             )\n//         });\n\n//         return (\n//             <ul className=\"char__grid\">\n//                 {items}\n//             </ul>\n//         )\n//     }\n\n//     render() {\n//         const {charList, loading, error, newItemLoading, offset, charEnded} = this.state; \n//         const items = this.renderItems(charList);\n\n//         const errorMessage = error ? <ErrorMessage></ErrorMessage> : null; \n//         const spinner = loading ? <Spinner></Spinner> : null; \n//         const content = (!error && !loading) ? items : null; // если нет загрузки и нет ошибки, будет показан контент с данными о персонаже, иначе null\n\n//         return (\n//             <div className=\"char__list\">\n//                 {errorMessage}\n//                 {spinner}\n//                 {content}\n//                 <button \n//                     className=\"button button__main button__long\"\n//                     disabled={newItemLoading}\n//                     style={{'display': charEnded ? 'none' : 'block'}}\n//                     onClick={() => this.onRequest(offset)}>\n//                     <div className=\"inner\">load more</div>\n//                 </button>\n//             </div>\n//         )\n//     }\n// }\n\nCharList.propTypes = {\n    onCharSelected: PropTypes.func.isRequired\n}\n\nexport default CharList;","import { useState, useEffect } from 'react';\nimport PropTypes from 'prop-types';\n\n// эти три импорта больше не нужны, т.к. они вшиты в setContent\n// import Spinner from '../spinner/Spinners';\n// import ErrorMessage from '../errorMessage/ErrorMessage';\n// import Skeleton from '../skeleton/Skeleton'\nimport useMarvelService from '../../services/MarvelService';\nimport setContent from '../../utils/setContent';\n\nimport './charInfo.scss';\n\n// это функциональный подход\nconst CharInfo = (props) => {\n    const [char, setChar] = useState(null); // по умолчанию ставим null, чтобы подгрузился компонент Skeleton\n    // убираем состояния ниже, они будут приходить из useMarvelService (подробнее, почему - в компоненте RandomChar)\n    // const [loading, setLoading] = useState(false); // изначально ставим false, потому что при загрузке страницы компонент будет заполнен данными по умолчанию (из компонента Skeleton)\n    // а уже когда пользователь будет кликать по списку героев, будет срабатывать обновление (или ошибка)\n    // const [error, setError] = useState(false); \n\n    const {loading, error, clearError, process, setProcess, getCharacter} = useMarvelService();\n    \n    // этот хук срабатывает при первой загрузке страницы, чтобы загрузились данные по умолчанию\n    useEffect(() => {\n        updateChar();\n    }, [])\n\n    const charId = props.charId;\n\n    // этот хук будет срабатывать при обновлении пропсов (а они будут меняться при каждом клике пользователя по списку героев)\n    useEffect(() => {\n        updateChar();\n    }, [charId]);\n\n    // создадим метод, который будет направлять запрос серверу и возвращать данные или ошибку\n    const updateChar = () => {\n        // const charId = props.charId;\n        if (!charId) {\n            return\n        }\n\n        clearError();\n        // onCharLoading(); // убираем благодаря useMarvelService\n        getCharacter(charId)\n            .then(onCharLoaded)\n            .then(() => setProcess('confirmed')) // процесс переходит в состояние подтверждённого (потому что получение данных от сервера сработало успешно)\n            // .catch(onError); // убираем благодаря useMarvelService\n    }\n\n    // пропишем метод, который будет обновлять стэйт char\n    const onCharLoaded = (char) => {\n        setChar(char);\n        // код ниже убираем благодаря useMarvelService\n        // setLoading(false); // если данные от сервера вернулись (стэйту char присвоилось какое-то значение), то loading переходит в состояние false, чтобы в вёрстке отобразились загруженные данные, а не спиннер загрузки\n    }\n\n    // пропишем метод, который будет запускать спиннер загрузки\n    // убираем благодаря useMarvelService\n    // const onCharLoading = () => {\n    //     setLoading(true);\n    // }\n\n    // создаём метод, который будет отображать ошибку, если от сервера не пришёл ответ\n    // убираем благодаря useMarvelService\n    // const onError = () => {\n    //     setLoading(false); // статус загрузки меняется на false, потому что она завершилась неудачно\n    //     setError(true);\n    // }\n\n    // т.к. мы используем setContent, это больше не нужно\n    // const skeleton = char || loading || error ? null : <Skeleton></Skeleton>; // если нет ошибки, загрузки или полученных данных о персонаже, т.е. при первой загрузке страницы, будет подгружен скелетон\n    // const errorMessage = error ? <ErrorMessage></ErrorMessage> : null; \n    // const spinner = loading ? <Spinner></Spinner> : null; \n    // const content = (!error && !loading && char) ? <View char={char}></View> : null;\n\n    return (\n        <div className=\"char__info\">\n            {setContent(process, View, char)}\n        </div>\n    )\n}\n\n// это классовый подход\n// class CharInfo extends Component{\n//     state = {\n//         char: null, // по умолчанию ставим null, чтобы подгрузился компонент Skeleton\n//         loading: false, // изначально ставим false, потому что при загрузке страницы компонент будет заполнен данными по умолчанию (из компонента Skeleton)\n//         // а уже когда пользователь будет кликать по списку героев, будет срабатывать обновление (или ошибка)\n//         error: false\n//     }\n\n//     marvelService = new MarvelService();\n    \n//     // этот хук срабатывает при первой загрузке страницы, чтобы загрузились данные по умолчанию\n//     componentDidMount() {\n//         this.updateChar();\n//     }\n\n//     // этот хук будет срабатывать при обновлении пропсов (а они будут меняться при каждом клике пользователя по списку героев)\n//     componentDidUpdate(prevProps) {\n//         // если не предусмотреть условия и просто прописать метод работы с сервером, он может срабатывать бесконечно\n//         if (this.props.charId !== prevProps.charId) { // если новые значения свойств отличаются от предыдущих, тогда будет срабатывать метод работы с сервером\n//             this.updateChar();\n//         }\n//     }\n\n//     // создадим метод, который будет направлять запрос серверу и возвращать данные или ошибку\n//     updateChar = () => {\n//         const {charId} = this.props;\n//         if (!charId) {\n//             return\n//         }\n\n//         this.onCharLoading();\n//         this.marvelService\n//             .getCharacter(charId)\n//             .then(this.onCharLoaded)\n//             .catch(this.onError);\n//     }\n\n//     // пропишем метод, который будет обновлять стэйт char\n//     onCharLoaded = (char) => {\n//         this.setState({\n//             char, \n//             loading: false}) // если данные от сервера вернулись (стэйту char присвоилось какое-то значение), то loading переходит в состояние false, чтобы в вёрстке отобразились загруженные данные, а не спиннер загрузки\n//     }\n\n//     // пропишем метод, который будет запускать спиннер загрузки\n//     onCharLoading = () => {\n//         this.setState({\n//             loading: true\n//         })\n//     }\n\n//     // создаём метод, который будет отображать ошибку, если от сервера не пришёл ответ\n//     onError = () => {\n//         this.setState({\n//             loading: false, // статус загрузки меняется на false, потому что она завершилась неудачно\n//             error: true})\n//     }\n\n\n//     render() {\n//         const {char, loading, error} = this.state; \n\n//         const skeleton = char || loading || error ? null : <Skeleton></Skeleton>; // если нет ошибки, загрузки или полученных данных о персонаже, т.е. при первой загрузке страницы, будет подгружен скелетон\n//         const errorMessage = error ? <ErrorMessage></ErrorMessage> : null; \n//         const spinner = loading ? <Spinner></Spinner> : null; \n//         const content = (!error && !loading && char) ? <View char={char}></View> : null;\n\n//         return (\n//             <div className=\"char__info\">\n//                 {skeleton}\n//                 {errorMessage}\n//                 {spinner}\n//                 {content}\n//             </div>\n//         )\n//     } \n// }\n\n// создадим компонент, кт будет отвечать только за вёрстку\nconst View = ({data}) => {\n    const {name, description, thumbnail, homepage, wiki, comics} = data;\n    let comicsList = comics.map((item, i) => {\n        return (\n            <li key={i} className=\"char__comics-item\">\n                {item.name}\n            </li>\n        )\n    }) \n    const defaultComicsList = `Комиксы с участием выбранного персонажа отсутствуют`;\n\n    let thumnailUrl = thumbnail === `http://i.annihil.us/u/prod/marvel/i/mg/b/40/image_not_available.jpg`;\n    let thumbnailStyle = thumnailUrl ? {objectFit: 'contain'} : null;\n\n    return (\n        <>\n            <div className=\"char__basics\">\n                <img src={thumbnail} alt={name} style={thumbnailStyle}/>\n                <div>\n                    <div className=\"char__info-name\">{name}</div>\n                    <div className=\"char__btns\">\n                        <a href={homepage} className=\"button button__main\">\n                            <div className=\"inner\">homepage</div>\n                        </a>\n                        <a href={wiki} className=\"button button__secondary\">\n                            <div className=\"inner\">Wiki</div>\n                        </a>\n                    </div>\n                </div>\n            </div>\n            <div className=\"char__descr\">\n                {description}\n            </div>\n            <div className=\"char__comics\">Comics:</div>\n            <ul className=\"char__comics-list\">\n                {comicsList.length === 0 ? defaultComicsList : comicsList}\n            </ul>\n        </>\n    )\n}\n\nCharInfo.propTypes = {\n    charId: PropTypes.number\n}\nexport default CharInfo;","import { Link } from 'react-router-dom';\r\nimport { useState } from 'react';\r\nimport useMarvelService from '../../services/MarvelService';\r\nimport { Formik, Form, Field, ErrorMessage } from 'formik';\r\nimport * as Yup from 'yup';\r\n\r\nimport './charForm.scss'\r\n\r\n\r\nconst CharForm = (props) => {\r\n    const [foundChar, setFoundChar] = useState(null);\r\n    const [charItem, setCharItem] = useState([]);\r\n\r\n    const {getChar} = useMarvelService();\r\n    const findChar = (name) => {\r\n        setFoundChar(null);\r\n        getChar()\r\n            .then(data => {\r\n                // setCharItem(data.filter(item => item.name === name));\r\n                // console.log(charItem);\r\n                const char = data.filter(item => item.name === name);\r\n                return char[0];\r\n            })\r\n            .then(char => {\r\n                if (char) {\r\n                    setCharItem(char);\r\n                    setFoundChar(char.name);\r\n                } else {\r\n                    setFoundChar(0);\r\n                }\r\n            })\r\n    }   \r\n    const positiveAnswer = <div className='form__result__plus'>\r\n            <p>There is! Visit {foundChar} page?</p>\r\n            <div>\r\n                <Link to={`/char/${charItem.id}`}>\r\n                    <button type='button' className='form__result__button'>TO PAGE</button>\r\n                </Link>\r\n            </div>\r\n\r\n        </div>;\r\n    const negativeAnswer = <div className='form__result__zero'>\r\n            <p>The character was not found. Check the name and try again</p>\r\n        </div>;\r\n    let answer = foundChar ? positiveAnswer : foundChar === 0 ? negativeAnswer : null;\r\n\r\n    return (\r\n        <Formik \r\n            initialValues={{\r\n                name: ''\r\n            }}\r\n            validationSchema={Yup.object({ \r\n                name: Yup.string().required('This field is required')\r\n            })}\r\n            onSubmit={values => {\r\n                findChar(values.name);\r\n                console.log(JSON.stringify(values, null, 2));\r\n            }}\r\n        >\r\n            <Form className='form' onChange={e => !e.target.value ? setFoundChar(null) : null}>\r\n                <label htmlFor=\"name\" className='form__label'><b>Or find a character by name:</b></label>\r\n                <Field\r\n                    id=\"name\"\r\n                    name=\"name\"\r\n                    type=\"text\"\r\n                    className=\"form__input\"\r\n                    placeholder='Enter name'\r\n                    // onChange={() => answer = null}\r\n                />\r\n                <button type=\"submit\" className='form__button'>FIND</button>\r\n                <ErrorMessage className=\"error\" name='name' component='div'/>\r\n                {answer}\r\n            </Form>\r\n        </Formik>\r\n    )\r\n}\r\n\r\nexport default CharForm;\r\n","// этот компонент будет отвечать за создание предохранителя,т.е. компонента, кт будет показываться в случае возникновения ошибки на странице\r\nimport { Component } from \"react\";\r\nimport ErrorMessage from \"../errorMessage/ErrorMessage\";\r\n\r\nclass ErrorBoundary extends Component{\r\n    state = {\r\n        error: false\r\n    }\r\n\r\n    // этот хук будет срабатывать при возникновении ошибки в компоненте\r\n    componentDidCatch(error, errorInfo) {\r\n        console.log(error, errorInfo);\r\n        this.setState({\r\n            error: true\r\n        });\r\n    }\r\n\r\n    render() {\r\n        if (this.state.error) {\r\n            return <ErrorMessage></ErrorMessage>\r\n        }\r\n        \r\n        return this.props.children;\r\n    }\r\n}\r\n\r\nexport default ErrorBoundary;","import { useState } from \"react\";\r\nimport { Helmet } from \"react-helmet\";\r\n\r\nimport RandomChar from \"../randomChar/RandomChar\";\r\nimport CharList from \"../charList/CharList\";\r\nimport CharInfo from \"../charInfo/CharInfo\";\r\nimport CharForm from \"../charForm/CharForm\";\r\nimport CharPage from \"../charPage/CharPage\";\r\nimport ErrorBoundary from \"../errorBoundary/ErrorBoundary\";\r\nimport decoration from '../../resources/img/vision.png';\r\n\r\nconst MainPage = () => {\r\n    const [selectedChar, setChar] = useState(null);\r\n    const [charName, setCharName] = useState(null);\r\n\r\n    // пропишем метод, кт будет устанавливать значение для selectedChar\r\n    const onCharSelected = (id) => {\r\n        setChar(id);\r\n    } // этот метод передадим как свойство в CharList, чтобы оттуда приходило значение стэйта\r\n\r\n    const onCharName = (id) => {\r\n        setCharName(id);\r\n    }\r\n\r\n    return(\r\n        <>\r\n            <Helmet>\r\n                <meta\r\n                    name=\"description\"\r\n                    content=\"Marvel information portal\"\r\n                />\r\n                <title>Marvel information portal</title>\r\n            </Helmet>\r\n            <ErrorBoundary>\r\n                <RandomChar/>\r\n            </ErrorBoundary>\r\n            <div className=\"char__content\">\r\n                <ErrorBoundary>\r\n                    <CharList onCharSelected={onCharSelected}/>\r\n                </ErrorBoundary>\r\n                <div>\r\n                    <ErrorBoundary>\r\n                        <CharInfo charId={selectedChar}/>\r\n                    </ErrorBoundary>\r\n                    <ErrorBoundary>\r\n                        <CharForm onCharName={onCharName}/>\r\n                    </ErrorBoundary>\r\n                </div>\r\n            </div>\r\n            <img className=\"bg-decoration\" src={decoration} alt=\"vision\"/>\r\n        </>\r\n    )\r\n}\r\n\r\nexport default MainPage;","import { useState, useCallback } from \"react\";\r\n\r\n// это будет хук, который объединит несколько методов, связанными с изменением статусов загрузки и ошибки во время направления запросов на серврер, т.к. они повторяются в разных элементах\r\n// кроме того, в этом хуке мы пропишем функцию по направлению запроса, которая будет выступать основой для похожей функции из MarvelService\r\nexport const useHttp = () => {\r\n    // эти два состояния больше не нужны, так как рендеринг компонентов, привязанных к ним, мы поставили в зависимость от значения состояния process\r\n    // const [loading, setLoading] = useState(false);\r\n    // const [error, setError] = useState(null);\r\n    const [process, setProcess] = useState('waiting'); // это состояние нужно для внедрения конечного автомата, по умолчанию стоит состояние ожидания\r\n\r\n    // это будет мемоизированная функция по направлению запроса, в ней также укажем параметры по умолчанию\r\n    const request = useCallback(async (url, method = 'GET', body = null, headers = {'Content-Type': 'application/json'}) => {\r\n        // больше не нужно благодаря состоянию process\r\n        // setLoading(true); // так как пошёл запрос на сервер, у загрузки статус меняется на true\r\n        setProcess('loading'); // процесс переходит в состояние загрузки\r\n        try { // направляем запрос\r\n            const response = await fetch(url, {method, body, headers}); // в эту переменную придёт ответ запроса\r\n            if (!response.ok) { // в случае ошибки будет выводиться сообщение об этом\r\n                throw new Error(`Could not fetch ${url}, status: ${response.status}`);\r\n            }\r\n            const data = await response.json(); // сюда помещается ответ от сервера, преобразованный в json\r\n            // больше не нужно благодаря состоянию process\r\n            // setLoading(false); // т.к. это ветка по успешному получению ответа от запроса, значит, в конце успеха статус загрузки прекращается\r\n            return data; // это не то же самое, что в MarvelService, потому что там возвращается трансформированные данные, а у нас изначальные от API\r\n        } catch(e) { // этот код на случай ошибки\r\n            // больше не нужны благодаря состоянию process\r\n            // setLoading(false); // загрузка завершилась неудачей, но завершилась, поэтому статус меняем на false\r\n            // setError(e.message); // вернётся текст ошибки\r\n            setProcess('error') // процесс переходит в состояние ошибки (что загрузка не сработала)\r\n            throw e; // выкидываем ошибку\r\n        }\r\n\r\n    }, [])\r\n\r\n    // эта функция будет очищать ошибку, если она была\r\n    const clearError = useCallback(() => {\r\n        // больше не нужно благодаря состоянию process\r\n        // setError(null);\r\n        setProcess('loading'); // процесс вновь переходит в состояние загрузки\r\n    }, []);\r\n\r\n    // убираем loading и error, они больше не нужны благодаря process\r\n    return {request, clearError, process, setProcess};\r\n}","import { useHttp } from \"../hooks/http.hook\";\r\n\r\n// это код новый, с переделкой под хуки и функциональный подход\r\nconst useMarvelService = () => {\r\n    // через деструктуризацию вытащим интересующие нас части useHttp\r\n    const {loading, request, error, clearError, process, setProcess} = useHttp();\r\n    // т.к. запрос на сайт имеет одинаковые части, можно сократить url, введя переменные\r\n    const _apiBase ='https://gateway.marvel.com:443/v1/public/';\r\n    const _apiKey = 'apikey=677f4f151277ce2120c892cebbe0e1ba';\r\n    const _baseOffset = 200; // эта переменная означает отступ в количестве персонажей, начиная с первого, в запросе на сервер\r\n\r\n    // создадим несколько методов, которые будут упрощать работу\r\n    // метод по получению данных о всех персонажах\r\n    const getAllCharacters = async (offset = _baseOffset) => { // предусматриваем переменную и значение по умолчанию, потому что эта переменная может меняться\r\n        const res = await request(`${_apiBase}characters?limit=9&offset=${offset}&${_apiKey}`);\r\n        return res.data.results.map(_transformCharacter);\r\n    }\r\n    // метод по получению данных о конкретном персонаже\r\n    const getCharacter = async (id) => {\r\n        const res = await request(`${_apiBase}characters/${id}?${_apiKey}`); // получили данные от сервера\r\n        return _transformCharacter(res.data.results[0]); // возвращаем их уже в преобразованном виде\r\n    }\r\n    // метод по трансформации данных о персонажах, он будет полученные данные от сервера превращать в объект, кт мы используем в компонентах (там этот объект является объектом state)\r\n    const _transformCharacter = (char) => {\r\n        let description = char.description;\r\n        description = description ? `${description.slice(0, 200)}...` : `Описание данного персонажа отсутствует`;\r\n\r\n        return {\r\n            id: char.id,\r\n            name: char.name,\r\n            description: description,\r\n            thumbnail: `${char.thumbnail.path}.${char.thumbnail.extension}`,\r\n            homepage: char.urls[0].url,\r\n            wiki: char.urls[1].url,\r\n            comics: char.comics.items.slice(0, 10),\r\n            title: char.title,\r\n        }\r\n    }\r\n\r\n    // метод по трансформации данных о комиксах, он будет полученные данные от сервера превращать в объект, кт мы используем в компонентах (там этот объект является объектом state)\r\n    const _transformComics = (comics) => {\r\n        let price = comics.prices[0].price;\r\n        price = price ? `${comics.prices[0].price}$` : `Комикс отсутствует в продаже`;\r\n\r\n        return {\r\n            id: comics.id,\r\n            description: comics.description || 'Описание комикса отсутствует',\r\n            thumbnail: `${comics.thumbnail.path}.${comics.thumbnail.extension}`,\r\n            title: comics.title.length > 50\r\n                ? `${comics.title.slice(0, 50)}...`\r\n                : comics.title,\r\n            price: price,\r\n            language: comics.textObjects[0]?.language || \"en-us\",\r\n            pageCount: comics.pageCount\r\n\t\t\t\t? `${comics.pageCount} p.`\r\n\t\t\t\t: \"Информация о количестве листов в комиксе отсутствует\",\r\n        }\r\n    }\r\n\r\n    // метод по получению списка комиксов\r\n    const getAllComics = async (offset = _baseOffset) => {\r\n        const res = await request(`${_apiBase}comics?limit=8&offset=${offset}&${_apiKey}`);\r\n        return res.data.results.map(_transformComics);\r\n    }\r\n    // метод по получению конкретного комикса\r\n    const getComics = async (id) => {\r\n\t\tconst res = await request(`${_apiBase}comics/${id}?${_apiKey}`);\r\n\t\treturn _transformComics(res.data.results[0]);\r\n\t};\r\n\r\n    // метод по получению данных о конкретном персонаже\r\n    const getChar = async () => {\r\n        const res = await request(`${_apiBase}characters?${_apiKey}`); // получили данные от сервера\r\n        return res.data.results.map(_transformCharacter);\r\n    }\r\n\r\n    // этот хук будет возвращать состояния загрузки и ошибки, а также два метода по получению всех персонажей и только одного персонажа\r\n    // благодаря process удаляем loading и error\r\n    return {\r\n            // loading, \r\n            // error, \r\n            clearError, \r\n            process,\r\n            setProcess,\r\n            getAllCharacters, \r\n            getCharacter, \r\n            getAllComics, \r\n            getComics, \r\n            getChar\r\n        }\r\n}\r\n\r\n// этот код старый, до переделки его в хуки\r\n// мы не импортируем Components и не наследуем от него, потому что это отдельный класс, в котором не будет ничего от React\r\n// class MarvelService {\r\n//     // т.к. запрос на сайт имеет одинаковые части, можно сократить url, введя переменные\r\n//     _apiBase ='https://gateway.marvel.com:443/v1/public/';\r\n//     _apiKey = 'apikey=677f4f151277ce2120c892cebbe0e1ba';\r\n//     _baseOffset = 200; // эта переменная означает отступ в количестве персонажей, начиная с первого, в запросе на сервер\r\n    \r\n//     // создали функцию (метод), которая будет делать запрос\r\n//     getResource = async (url) => {\r\n//         let res = await fetch(url);\r\n\r\n//         if (!res.ok) { // в случае ошибки будет выводиться сообщение об этом\r\n//             throw new Error(`Could not fetch ${url}, status: ${res.status}`);\r\n//         }\r\n\r\n//         return await res.json(); // если всё хорошо, будут возвращаться данные в формате json\r\n//     };\r\n\r\n//     // создадим несколько методов, которые будут упрощать работу с классом\r\n//     // метод по получению данных о всех персонажах\r\n//     getAllCharacters = async (offset = this._baseOffset) => { // предусматриваем переменную и значение по умолчанию, потому что эта переменная может меняться\r\n//         const res = await this.getResource(`${this._apiBase}characters?limit=9&offset=${offset}&${this._apiKey}`);\r\n//         return res.data.results.map(this._transformCharacter);\r\n//     }\r\n//     // метод по получению данных о конкретном персонаже\r\n//     getCharacter = async (id) => {\r\n//         const res = await this.getResource(`${this._apiBase}characters/${id}?${this._apiKey}`); // получили данные от сервера\r\n//         return this._transformCharacter(res.data.results[0]); // возвращаем их уже в преобразованном виде\r\n//     }\r\n//     // метод по трансформации данных, он будет полученные данные от сервера превращать в объект, кт мы используем в компонентах (там этот объект является объектом state)\r\n//     _transformCharacter = (char) => {\r\n//         let description = char.description;\r\n//         description = description ? `${description.slice(0, 200)}...` : `Описание данного персонажа отсутствует`;\r\n\r\n//         return {\r\n//             id: char.id,\r\n//             name: char.name,\r\n//             description: description,\r\n//             thumbnail: `${char.thumbnail.path}.${char.thumbnail.extension}`,\r\n//             homepage: char.urls[0].url,\r\n//             wiki: char.urls[1].url,\r\n//             comics: char.comics.items.slice(0, 10)\r\n//         }\r\n//     }\r\n// }\r\n\r\nexport default useMarvelService;\r\n","import './skeleton.scss';\n\nconst Skeleton = () => {\n    return (\n        <>\n            <p className=\"char__select\">Please select a character to see information</p>\n            <div className=\"skeleton\">\n                <div className=\"pulse skeleton__header\">\n                    <div className=\"pulse skeleton__circle\"></div>\n                    <div className=\"pulse skeleton__mini\"></div>\n                </div>\n                <div className=\"pulse skeleton__block\"></div>\n                <div className=\"pulse skeleton__block\"></div>\n                <div className=\"pulse skeleton__block\"></div>\n            </div>\n        </>\n    )\n}\n\nexport default Skeleton;","import Spinner from '../components/spinner/Spinners';\r\nimport ErrorMessage from '../components/errorMessage/ErrorMessage';\r\nimport Skeleton from '../components/skeleton/Skeleton'\r\n\r\n// поскольку подобный блок логики повторяется в нескольких компонентах, мы его выделили в отдельную функцию в отдельном файле\r\nconst setContent = (process, Component, data) => {\r\n    switch(process) {\r\n        case 'waiting':\r\n            return <Skeleton/>; // если у состояния процесса значение ожидания, значит, ещё не был отправлен запрос на сервер и пока на сайте у компонента стоит заглушка\r\n        case 'loading':\r\n            return <Spinner/>; // если у состояния процесса значение загрузки, значит, запрос отправлен на сервер, но нет никакого ответа, поэтому будет показываться компонент загрузки\r\n        case 'confirmed':\r\n            return <Component data={data}/>; // если у состояния процесса значение подтверждено, значит, от сервера пришли данные, а не ошибка, тогда загружается полученный контент\r\n        case 'error':\r\n            return <ErrorMessage/>; // если у состония процесса значение ошибки, значит, от сервера не пришли данные, а возникла ошибка, тогда показывается компонент с ошибкой\r\n        default:\r\n            throw new Error('Unexpected process state');\r\n    }\r\n}\r\n\r\nexport default setContent;"],"names":["CharPage","id","useParams","char","setChar","useState","loading","error","clearError","getCharacter","process","setProcess","useMarvelService","useEffect","updateChar","then","data","_jsx","_Fragment","children","setContent","View","_ref","thumbnail","description","name","_jsxs","className","Helmet","content","concat","src","alt","ErrorMessage","style","display","width","height","objectFit","margin","imgError","homepage","wiki","thumbnailStyle","href","RandomChar","onCharLoaded","Math","floor","random","onClick","mjolnir","props","charList","setCharList","newItemLoading","setNewItemLoading","offset","setOffset","charEnded","setCharEnded","getAllCharacters","onRequest","initial","onCharListLoaded","newCharList","ended","length","itemRefs","useRef","focusOnItem","current","forEach","item","classList","remove","add","focus","elements","useMemo","Component","Spinner","Error","arr","items","map","i","imgStyle","CSSTransition","in","timeout","classNames","tabIndex","ref","el","onCharSelected","onKeyPress","e","key","TransitionGroup","component","renderItems","disabled","comics","comicsList","charId","foundChar","setFoundChar","charItem","setCharItem","getChar","positiveAnswer","Link","to","type","answer","Formik","initialValues","validationSchema","Yup","required","onSubmit","values","filter","console","log","JSON","stringify","Form","onChange","target","value","htmlFor","Field","placeholder","ErrorBoundary","constructor","arguments","state","componentDidCatch","errorInfo","this","setState","render","MainPage","selectedChar","charName","setCharName","CharList","CharInfo","CharForm","onCharName","decoration","request","useHttp","useCallback","async","url","method","undefined","body","headers","response","fetch","ok","status","json","_apiBase","_apiKey","_transformCharacter","slice","path","extension","urls","title","_transformComics","_comics$textObjects$","price","prices","language","textObjects","pageCount","results","res","getAllComics","getComics","Skeleton"],"sourceRoot":""}