{"version":3,"file":"static/js/734.a9185078.chunk.js","mappings":"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","sources":["components/errorMessage/ErrorMessage.js","components/appBanner/AppBanner.js","components/comicsList/comicsList.js","components/pages/ComicsPage.js","hooks/http.hook.js","services/MarvelService.js"],"sourcesContent":["import imgError from './error.gif'\r\n\r\nconst ErrorMessage = () => {\r\n    return (\r\n        <img style={{ display: 'block', width: \"250px\", height: \"250px\",objectFit: 'contain', margin: \"0 auto\"}} src={imgError} alt={'Ошибка загрузки'}></img>\r\n    )\r\n}\r\n\r\nexport default ErrorMessage;","import './appBanner.scss';\nimport avengers from '../../resources/img/Avengers.png';\nimport avengersLogo from '../../resources/img/Avengers_logo.png';\n\nconst AppBanner = () => {\n    return (\n        <div className=\"app__banner\">\n            <img src={avengers} alt=\"Avengers\"/>\n            <div className=\"app__banner-text\">\n                New comics every week!<br/>\n                Stay tuned!\n            </div>\n            <img src={avengersLogo} alt=\"Avengers logo\"/>\n        </div>\n    )\n}\n\nexport default AppBanner;","import { useState, useEffect, useRef } from 'react';\r\nimport { Link } from 'react-router-dom';\r\n\r\nimport useMarvelService from '../../services/MarvelService';\r\nimport ErrorMessage from '../errorMessage/ErrorMessage';\r\nimport Spinner from '../spinner/Spinners';\r\n\r\nimport './comicsList.scss';\r\n\r\n// вместо импорта setContent мы сами создаём такую же функцию, потому что у неё надо прописать немного другую логику\r\nconst setContent = (process, Component, newItemLoading) => {\r\n    switch(process) {\r\n        case 'waiting':\r\n            return <Spinner/>; // если у состояния процесса значение ожидания, значит, ещё не был отправлен запрос на сервер и пока на сайте у компонента стоит спиннер загрузки\r\n            break;\r\n        case 'loading':\r\n            return newItemLoading ? <Component/> : <Spinner/>; // если у состояния процесса значение загрузки и при этом идёт первая загрузка персонажей, значит, запрос пока впервые отправлен на сервер, поэтому будет показываться компонент загрузки, \r\n            // если будет не первая загрузка, а дозагрузка, показываться будет не спиннер загрузки, а ранее загруженные персонажи\r\n            break;\r\n        case 'confirmed':\r\n            return <Component/>; // если у состояния процесса значение подтверждено, значит, от сервера пришли данные, а не ошибка, тогда загружается полученный контент\r\n            break;\r\n        case 'error':\r\n            return <ErrorMessage/>; // если у состония процесса значение ошибки, значит, от сервера не пришли данные, а возникла ошибка, тогда показывается компонент с ошибкой\r\n            break;\r\n        default:\r\n            throw new Error('Unexpected process state');\r\n    }\r\n}\r\n\r\nconst ComicsList = (props) => {\r\n\r\n    const [comicsList, setComicsList] = useState([]);\r\n\r\n    const [newItemLoading, setNewItemLoading] = useState(false);\r\n    const [offset, setOffset] = useState(210);\r\n    const [comicsEnded, setCharEnded] = useState(false);\r\n    const {loading, error, process, setProcess, getAllComics} = useMarvelService();\r\n\r\n    useEffect(() => { // мы можем написать useEffect здесь, до объявления стрелочной функции, потому что useEffect запускается после рендеринга, а к этому времени функция уже будет объявлена\r\n        onRequest(offset, true);\r\n    }, []) // поставили пустой массив, чтобы сработало один раз при первом рендеринге\r\n\r\n    // метод по запросу на сервер\r\n    const onRequest = (offset, initial) => {\r\n        // если initial стоит в true, т.е. идёт первая загрузка, то спиннер загрузки дополнительных персонажей не появляется, в ином случае будет появляться\r\n        initial ? setNewItemLoading(false) : setNewItemLoading(true);\r\n        getAllComics(offset) // получаем только нужные и уже преобразованные данные о персонажах\r\n            .then(onCharListLoaded) // обновляем стэйт char данными о персонажах\r\n            .then(() => setProcess('confirmed'));\r\n    }\r\n\r\n    // этот метод, в целом, отвечает за процесс загрузки списка персонажей\r\n    const onCharListLoaded = (newComicsList) => { // как параметр получает новый массив (это массив, кт будет приходить от сервера, состоящий всегда из 9 персонажей)\r\n        let ended = false; // эта переменная будет использоваться как значение для стэйта charEnded\r\n        if (newComicsList.length < 8) { // если от сервера пришло меньше 8 комиксов, значит, мы дошли до конца списка комиксов\r\n            ended = true;\r\n        }\r\n        // там, где важно предыдущее значение состояния, используем коллбэк-фукнции, в остальных местах можно просто присваивать новые значения\r\n        setComicsList(comicsList => [...comicsList, ...newComicsList]); // обновляем стэйт charList, перезаписывая в качестве его значения прежнее значение плюс новый массив, пришедший от сервера\r\n        setNewItemLoading(false); \r\n        setOffset(offset => offset + 8); // при каждом срабатывании метода будет меняться значение этого стэйта\r\n        setCharEnded(ended); // если сюда попадёт true, значит, мы дошли до конца списка персонажей, это будет ниже вызывать код, убирающий кнопку дозагрузки со страницы\r\n    }\r\n\r\n    const itemRefs = useRef([]); // пока что это пустой массив, в будущем в него будут помещаться карточки персонажей\r\n\r\n    // const focusOnItem = (id) => {\r\n    //     itemRefs.current.forEach(item => item.classList.remove('char__item_selected'));\r\n    //     itemRefs.current[id].classList.add('char__item_selected');\r\n    //     itemRefs.current[id].focus();\r\n    // }\r\n\r\n    // Этот метод создан для оптимизации, чтобы не помещать такую конструкцию в метод render\r\n    function renderItems(arr) {\r\n        const items =  arr.map((item, i) => {\r\n            // А эта конструкция вынесена для центровки спиннера/ошибки\r\n            return (\r\n                // при переборе каждый элемент будет заполнять массив itemRefs с карточками персонажей\r\n                <div>\r\n                    <li \r\n                        className=\"comics__item\"\r\n                        tabIndex={0}\r\n                        key={i}\r\n                        ref={el => itemRefs.current[i] = el}> \r\n                        <Link to={`/comics/${item.id}`}>\r\n                            <img src={item.thumbnail} alt={item.title} className='comics__item-img'/>\r\n                            <div className=\"comics__item-name\">{item.title}</div>\r\n                            <div className=\"comics__item-price\">{item.price}</div>\r\n                        </Link>\r\n                    </li>\r\n                </div>\r\n\r\n\r\n            )\r\n        });\r\n\r\n        return (\r\n            <ul className=\"comics__grid\">\r\n                {items}\r\n            </ul>\r\n        )\r\n    }\r\n\r\n    // const items = renderItems(comicsList);\r\n\r\n    // const errorMessage = error ? <ErrorMessage></ErrorMessage> : null; \r\n    // const spinner = loading && !newItemLoading ? <Spinner></Spinner> : null; \r\n    \r\n    return (\r\n        <div className=\"comics__list\">\r\n            {/* т.к. в аргументы setContent надо передавать компонент, а компонент это функция (сейчас всё на функциональных компонентах), возвращающая вёрстку, \r\n            то вторым аргументом передадим коллбэк-функцию, которая по итогу будет вызывать вёрстку, таким образом мы заменяем items*/}\r\n            {setContent(process, () => renderItems(comicsList), newItemLoading)} \r\n            <button \r\n                className=\"button button__main button__long\"\r\n                disabled={newItemLoading}\r\n                style={{'display': comicsEnded ? 'none' : 'block'}}\r\n                onClick={() => onRequest(offset)}>\r\n                <div className=\"inner\">load more</div>\r\n            </button>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default ComicsList;\r\n\r\n","import { Helmet } from 'react-helmet';\r\n\r\nimport AppBanner from '../appBanner/AppBanner';\r\nimport ComicsList from \"../comicsList/comicsList\";\r\n\r\nconst ComicsPage = () => {\r\n    return (\r\n        <>\r\n            <Helmet>\r\n                <meta\r\n                    name=\"description\"\r\n                    content=\"Page with list of our comics\"\r\n                />\r\n                <title>Comics page</title>\r\n            </Helmet>\r\n            <AppBanner></AppBanner>\r\n            <ComicsList></ComicsList>\r\n        </>\r\n    )\r\n}\r\n\r\nexport default ComicsPage;","import { useState, useCallback } from \"react\";\r\n\r\n// это будет хук, который объединит несколько методов, связанными с изменением статусов загрузки и ошибки во время направления запросов на серврер, т.к. они повторяются в разных элементах\r\n// кроме того, в этом хуке мы пропишем функцию по направлению запроса, которая будет выступать основой для похожей функции из MarvelService\r\nexport const useHttp = () => {\r\n    // эти два состояния больше не нужны, так как рендеринг компонентов, привязанных к ним, мы поставили в зависимость от значения состояния process\r\n    // const [loading, setLoading] = useState(false);\r\n    // const [error, setError] = useState(null);\r\n    const [process, setProcess] = useState('waiting'); // это состояние нужно для внедрения конечного автомата, по умолчанию стоит состояние ожидания\r\n\r\n    // это будет мемоизированная функция по направлению запроса, в ней также укажем параметры по умолчанию\r\n    const request = useCallback(async (url, method = 'GET', body = null, headers = {'Content-Type': 'application/json'}) => {\r\n        // больше не нужно благодаря состоянию process\r\n        // setLoading(true); // так как пошёл запрос на сервер, у загрузки статус меняется на true\r\n        setProcess('loading'); // процесс переходит в состояние загрузки\r\n        try { // направляем запрос\r\n            const response = await fetch(url, {method, body, headers}); // в эту переменную придёт ответ запроса\r\n            if (!response.ok) { // в случае ошибки будет выводиться сообщение об этом\r\n                throw new Error(`Could not fetch ${url}, status: ${response.status}`);\r\n            }\r\n            const data = await response.json(); // сюда помещается ответ от сервера, преобразованный в json\r\n            // больше не нужно благодаря состоянию process\r\n            // setLoading(false); // т.к. это ветка по успешному получению ответа от запроса, значит, в конце успеха статус загрузки прекращается\r\n            return data; // это не то же самое, что в MarvelService, потому что там возвращается трансформированные данные, а у нас изначальные от API\r\n        } catch(e) { // этот код на случай ошибки\r\n            // больше не нужны благодаря состоянию process\r\n            // setLoading(false); // загрузка завершилась неудачей, но завершилась, поэтому статус меняем на false\r\n            // setError(e.message); // вернётся текст ошибки\r\n            setProcess('error') // процесс переходит в состояние ошибки (что загрузка не сработала)\r\n            throw e; // выкидываем ошибку\r\n        }\r\n\r\n    }, [])\r\n\r\n    // эта функция будет очищать ошибку, если она была\r\n    const clearError = useCallback(() => {\r\n        // больше не нужно благодаря состоянию process\r\n        // setError(null);\r\n        setProcess('loading'); // процесс вновь переходит в состояние загрузки\r\n    }, []);\r\n\r\n    // убираем loading и error, они больше не нужны благодаря process\r\n    return {request, clearError, process, setProcess};\r\n}","import { useHttp } from \"../hooks/http.hook\";\r\n\r\n// это код новый, с переделкой под хуки и функциональный подход\r\nconst useMarvelService = () => {\r\n    // через деструктуризацию вытащим интересующие нас части useHttp\r\n    const {loading, request, error, clearError, process, setProcess} = useHttp();\r\n    // т.к. запрос на сайт имеет одинаковые части, можно сократить url, введя переменные\r\n    const _apiBase ='https://gateway.marvel.com:443/v1/public/';\r\n    const _apiKey = 'apikey=677f4f151277ce2120c892cebbe0e1ba';\r\n    const _baseOffset = 200; // эта переменная означает отступ в количестве персонажей, начиная с первого, в запросе на сервер\r\n\r\n    // создадим несколько методов, которые будут упрощать работу\r\n    // метод по получению данных о всех персонажах\r\n    const getAllCharacters = async (offset = _baseOffset) => { // предусматриваем переменную и значение по умолчанию, потому что эта переменная может меняться\r\n        const res = await request(`${_apiBase}characters?limit=9&offset=${offset}&${_apiKey}`);\r\n        return res.data.results.map(_transformCharacter);\r\n    }\r\n    // метод по получению данных о конкретном персонаже\r\n    const getCharacter = async (id) => {\r\n        const res = await request(`${_apiBase}characters/${id}?${_apiKey}`); // получили данные от сервера\r\n        return _transformCharacter(res.data.results[0]); // возвращаем их уже в преобразованном виде\r\n    }\r\n    // метод по трансформации данных о персонажах, он будет полученные данные от сервера превращать в объект, кт мы используем в компонентах (там этот объект является объектом state)\r\n    const _transformCharacter = (char) => {\r\n        let description = char.description;\r\n        description = description ? `${description.slice(0, 200)}...` : `Описание данного персонажа отсутствует`;\r\n\r\n        return {\r\n            id: char.id,\r\n            name: char.name,\r\n            description: description,\r\n            thumbnail: `${char.thumbnail.path}.${char.thumbnail.extension}`,\r\n            homepage: char.urls[0].url,\r\n            wiki: char.urls[1].url,\r\n            comics: char.comics.items.slice(0, 10),\r\n            title: char.title,\r\n        }\r\n    }\r\n\r\n    // метод по трансформации данных о комиксах, он будет полученные данные от сервера превращать в объект, кт мы используем в компонентах (там этот объект является объектом state)\r\n    const _transformComics = (comics) => {\r\n        let price = comics.prices[0].price;\r\n        price = price ? `${comics.prices[0].price}$` : `Комикс отсутствует в продаже`;\r\n\r\n        return {\r\n            id: comics.id,\r\n            description: comics.description || 'Описание комикса отсутствует',\r\n            thumbnail: `${comics.thumbnail.path}.${comics.thumbnail.extension}`,\r\n            title: comics.title.length > 50\r\n                ? `${comics.title.slice(0, 50)}...`\r\n                : comics.title,\r\n            price: price,\r\n            language: comics.textObjects[0]?.language || \"en-us\",\r\n            pageCount: comics.pageCount\r\n\t\t\t\t? `${comics.pageCount} p.`\r\n\t\t\t\t: \"Информация о количестве листов в комиксе отсутствует\",\r\n        }\r\n    }\r\n\r\n    // метод по получению списка комиксов\r\n    const getAllComics = async (offset = _baseOffset) => {\r\n        const res = await request(`${_apiBase}comics?limit=8&offset=${offset}&${_apiKey}`);\r\n        return res.data.results.map(_transformComics);\r\n    }\r\n    // метод по получению конкретного комикса\r\n    const getComics = async (id) => {\r\n\t\tconst res = await request(`${_apiBase}comics/${id}?${_apiKey}`);\r\n\t\treturn _transformComics(res.data.results[0]);\r\n\t};\r\n\r\n    // метод по получению данных о конкретном персонаже\r\n    const getChar = async () => {\r\n        const res = await request(`${_apiBase}characters?${_apiKey}`); // получили данные от сервера\r\n        return res.data.results.map(_transformCharacter);\r\n    }\r\n\r\n    // этот хук будет возвращать состояния загрузки и ошибки, а также два метода по получению всех персонажей и только одного персонажа\r\n    // благодаря process удаляем loading и error\r\n    return {\r\n            // loading, \r\n            // error, \r\n            clearError, \r\n            process,\r\n            setProcess,\r\n            getAllCharacters, \r\n            getCharacter, \r\n            getAllComics, \r\n            getComics, \r\n            getChar\r\n        }\r\n}\r\n\r\n// этот код старый, до переделки его в хуки\r\n// мы не импортируем Components и не наследуем от него, потому что это отдельный класс, в котором не будет ничего от React\r\n// class MarvelService {\r\n//     // т.к. запрос на сайт имеет одинаковые части, можно сократить url, введя переменные\r\n//     _apiBase ='https://gateway.marvel.com:443/v1/public/';\r\n//     _apiKey = 'apikey=677f4f151277ce2120c892cebbe0e1ba';\r\n//     _baseOffset = 200; // эта переменная означает отступ в количестве персонажей, начиная с первого, в запросе на сервер\r\n    \r\n//     // создали функцию (метод), которая будет делать запрос\r\n//     getResource = async (url) => {\r\n//         let res = await fetch(url);\r\n\r\n//         if (!res.ok) { // в случае ошибки будет выводиться сообщение об этом\r\n//             throw new Error(`Could not fetch ${url}, status: ${res.status}`);\r\n//         }\r\n\r\n//         return await res.json(); // если всё хорошо, будут возвращаться данные в формате json\r\n//     };\r\n\r\n//     // создадим несколько методов, которые будут упрощать работу с классом\r\n//     // метод по получению данных о всех персонажах\r\n//     getAllCharacters = async (offset = this._baseOffset) => { // предусматриваем переменную и значение по умолчанию, потому что эта переменная может меняться\r\n//         const res = await this.getResource(`${this._apiBase}characters?limit=9&offset=${offset}&${this._apiKey}`);\r\n//         return res.data.results.map(this._transformCharacter);\r\n//     }\r\n//     // метод по получению данных о конкретном персонаже\r\n//     getCharacter = async (id) => {\r\n//         const res = await this.getResource(`${this._apiBase}characters/${id}?${this._apiKey}`); // получили данные от сервера\r\n//         return this._transformCharacter(res.data.results[0]); // возвращаем их уже в преобразованном виде\r\n//     }\r\n//     // метод по трансформации данных, он будет полученные данные от сервера превращать в объект, кт мы используем в компонентах (там этот объект является объектом state)\r\n//     _transformCharacter = (char) => {\r\n//         let description = char.description;\r\n//         description = description ? `${description.slice(0, 200)}...` : `Описание данного персонажа отсутствует`;\r\n\r\n//         return {\r\n//             id: char.id,\r\n//             name: char.name,\r\n//             description: description,\r\n//             thumbnail: `${char.thumbnail.path}.${char.thumbnail.extension}`,\r\n//             homepage: char.urls[0].url,\r\n//             wiki: char.urls[1].url,\r\n//             comics: char.comics.items.slice(0, 10)\r\n//         }\r\n//     }\r\n// }\r\n\r\nexport default useMarvelService;\r\n"],"names":["ErrorMessage","_jsx","style","display","width","height","objectFit","margin","src","imgError","alt","AppBanner","_jsxs","className","children","avengers","avengersLogo","setContent","process","Component","newItemLoading","Spinner","Error","props","comicsList","setComicsList","useState","setNewItemLoading","offset","setOffset","comicsEnded","setCharEnded","loading","error","setProcess","getAllComics","useMarvelService","useEffect","onRequest","initial","then","onCharListLoaded","newComicsList","ended","length","itemRefs","useRef","arr","items","map","item","i","tabIndex","ref","el","current","Link","to","concat","id","thumbnail","title","price","renderItems","disabled","onClick","ComicsPage","_Fragment","Helmet","name","content","ComicsList","request","clearError","useHttp","useCallback","async","url","method","arguments","undefined","body","headers","response","fetch","ok","status","json","e","_apiBase","_apiKey","_transformCharacter","char","description","slice","path","extension","homepage","urls","wiki","comics","_transformComics","_comics$textObjects$","prices","language","textObjects","pageCount","getAllCharacters","data","results","getCharacter","res","getComics","getChar"],"sourceRoot":""}